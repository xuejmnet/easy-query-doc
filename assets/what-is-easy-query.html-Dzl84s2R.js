import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,b as a,o}from"./app-DvB_5WTW.js";const r={};function s(n,e){return o(),i("div",null,e[0]||(e[0]=[a('<h1 id="easy-query-introduction" tabindex="-1"><a class="header-anchor" href="#easy-query-introduction"><span>easy-query Introduction</span></a></h1><h1 id="qq-group" tabindex="-1"><a class="header-anchor" href="#qq-group"><span>QQ Group</span></a></h1><p>EasyQuery Official QQ Group: 170029046</p><div class="hint-container tip"><p class="hint-container-title">easy-query Features!!!</p><blockquote><p>The most powerful <code>ORM</code> for Java that truly understands queries, perfectly implementing both automatic and manual handling of complex object relationships<br> Implicit join, implicit subquery, implicit grouping, implicit partition grouping, implicit case when, sharding, field encryption search, manual join multi-table subquery grouping, code-first automatic table structure creation, automatic assembly of structured object data......</p></blockquote></div><h2 id="the-evolution-of-easy-query" tabindex="-1"><a class="header-anchor" href="#the-evolution-of-easy-query"><span>The Evolution of easy-query</span></a></h2><p><code>easy-query</code> is a domestic ORM that began in February 2023. Its original intention was to allow Java to operate databases like .NET. The framework supports both <code>Java</code> and <code>Kotlin</code>. 🚀 The only ORM in Java that supports both strongly-typed object relational queries and strongly-typed SQL syntax queries, featuring object model filtering, implicit subqueries, implicit join, explicit subqueries, explicit join. We&#39;ll refer to this framework as <code>eq</code> for short.</p><h2 id="four-super-features" tabindex="-1"><a class="header-anchor" href="#four-super-features"><span>Four Super Features</span></a></h2><ul><li><ol><li>Implicit Queries: Implicit Join, Implicit Subquery, Implicit Group, Implicit Partition, Implicit CaseWhen, Implicit RECURSIVE recursion</li></ol></li><li><ol start="2"><li>Explicit Queries: Explicit Join, Explicit Subquery, Explicit Group, Explicit Partition, Explicit CaseWhen</li></ol></li><li><ol start="3"><li>DTO Queries: <code>whereObject</code>, <code>orderByObject</code>, <code>selectAutoInclude</code> support filtering, sorting, and returning arbitrarily nested object structures in object mode</li></ol></li><li><ol start="4"><li>Support direct SQL query execution</li></ol></li></ul><h2 id="target-audience" tabindex="-1"><a class="header-anchor" href="#target-audience"><span>Target Audience</span></a></h2><ul><li>Have <code>SQL</code> basics, know <code>Java Stream</code>, know <code>C# Linq</code></li><li><code>JPA</code> or <code>Hibernate</code> users</li><li>.NET programmers transitioning to Java - <strong>strongly</strong> recommend you&#39;ll have a different experience from <code>.net</code> ORM++</li><li>Like strongly-typed DSL, tired of XML hand-written string SQL</li></ul><h2 id="advantages" tabindex="-1"><a class="header-anchor" href="#advantages"><span>Advantages</span></a></h2><ul><li><ol><li>Strongly-typed with intelligent hints and plugin hints</li></ol></li><li><ol start="2"><li>Expressions are easy to read, easy to maintain, high-performance SQL generation</li></ol></li><li><ol start="3"><li>Multi-database support with automatic DDL synchronization</li></ol></li><li><ol start="4"><li>Support mixing expressions with native SQL fragments</li></ol></li><li><ol start="5"><li>Fully open source and free including source code, plugins, and documentation</li></ol></li><li><ol start="6"><li>All configurations use Java objects, supporting seamless database switching</li></ol></li><li><ol start="7"><li>Can perfectly integrate with existing frameworks without conflicts</li></ol></li><li><ol start="8"><li>Achieves excellent balance between performance and dynamicity, meeting nearly 100% of requirements</li></ol></li></ul><h2 id="disadvantages" tabindex="-1"><a class="header-anchor" href="#disadvantages"><span>Disadvantages</span></a></h2><ul><li><ol><li>Learning curve is relatively high at the start but low afterwards, yet very rewarding</li></ol></li><li><ol start="2"><li>Through APT technology, users without plugins or non-IDEA users need to compile first to get corresponding classes (plugins available for real-time compilation awareness)</li></ol></li></ul><h2 id="use-cases" tabindex="-1"><a class="header-anchor" href="#use-cases"><span>Use Cases</span></a></h2><p><code>eq</code> is suitable for any JDBC-supported relational database, and users can customize dialects. It supports data model modeling, filtering, and fetching, efficiently implementing CRUD for single and multiple tables.</p><p>Supports writing database expression queries in <code>DSL</code> mode or using <code>relation model</code> for data model relationship filtering.</p><h2 id="why-choose-eq" tabindex="-1"><a class="header-anchor" href="#why-choose-eq"><span>Why Choose eq</span></a></h2><ul><li>Provides powerful object-oriented query functionality, mapping table relationships to object data structure relationships with simple APIs</li><li>Strongly-typed can handle most errors at compile time</li><li>Weakly-typed allows users to use string properties in dynamic scenarios combined with strongly-typed DSL</li><li>High coverage unit tests with 2000+ unit tests</li><li>The author uses it in production, already deployed in 5+ projects running stably for 1-2 years</li><li>Excellent performance with outstanding performance even in other ORM tests</li><li>Lightweight with zero dependencies, framework entirely self-implemented from scratch and controllable</li><li><code>OLTP</code>+<code>OLAP</code> full control, <code>SQL</code> optimization performance monster</li><li>All SQL tries to avoid <code>select *</code>; for a database with originally 5 columns that later becomes 4 columns, the program can immediately detect errors. If using <code>*</code>, it would only make that column null, causing data confusion</li></ul><p>If someone still asks why choose <code>eq</code>, I can responsibly tell you this framework has both very strong typing and very strong dynamic typing. You must be curious how <code>eq</code> achieves this.</p><p><code>eq</code> uses client mode in the lower layer of strongly-typed APIs for abstraction, and client mode can support any weak typing. Someone has implemented a complete low-code framework through the client API.</p><p>In addition to implementing low-code frameworks, it&#39;s compatible with all adapted databases, and users don&#39;t need to consider differences brought by dialects.</p><h2 id="database-support" tabindex="-1"><a class="header-anchor" href="#database-support"><span>Database Support</span></a></h2><table><thead><tr><th>Database Name</th><th>Package Name</th><th>SpringBoot Config</th><th>Solon Config</th></tr></thead><tbody><tr><td>MySQL</td><td>sql-mysql</td><td>mysql</td><td>mysql</td></tr><tr><td>Oracle</td><td>sql-oracle</td><td>oracle</td><td>oracle</td></tr><tr><td>PostgreSQL</td><td>sql-pgsql</td><td>pgsql</td><td>pgsql</td></tr><tr><td>SqlServer</td><td>sql-mssql</td><td>mssql</td><td>mssql</td></tr><tr><td>SqlServer RowNumber</td><td>sql-mssql</td><td>mssql_row_number</td><td>mssql_row_number</td></tr><tr><td>H2</td><td>sql-h2</td><td>h2</td><td>h2</td></tr><tr><td>SQLite</td><td>sql-sqlite</td><td>sqlite</td><td>sqlite</td></tr><tr><td>ClickHouse</td><td>sql-clickhouse</td><td>clickhouse</td><td>clickhouse</td></tr><tr><td>DaMeng</td><td>sql-dameng</td><td>dameng</td><td>dameng</td></tr><tr><td>KingbaseES</td><td>sql-kingbase-es</td><td>kingbase_es</td><td>kingbase_es</td></tr><tr><td>GaussDB</td><td>sql-gauss-db</td><td>gauss-db</td><td>gauss-db</td></tr><tr><td>DuckDB</td><td>sql-duckdb</td><td>duckdb</td><td>duckdb</td></tr><tr><td>DB2</td><td>sql-db2</td><td>db2</td><td>db2</td></tr></tbody></table><p><code>eq</code> currently has abstracted expressions, so in principle it supports all databases. You only need to customize the corresponding database&#39;s CRUD interface, which is <a href="https://github.com/xuejmnet/easy-query/tree/main/sql-db-support" target="_blank" rel="noopener noreferrer"><code>sql-db-support</code></a>. So if the corresponding SQL is not supported, you can extend it yourself or submit a corresponding issue.</p>',25)]))}const c=t(r,[["render",s]]),u=JSON.parse('{"path":"/en/what-is-easy-query.html","title":"What is EQ","lang":"en-US","frontmatter":{"title":"What is EQ","order":1,"category":["Startup"],"description":"easy-query Introduction QQ Group EasyQuery Official QQ Group: 170029046 easy-query Features!!! The most powerful ORM for Java that truly understands queries, perfectly implement...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"What is EQ\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-10-26T17:39:47.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xuejmnet\\",\\"url\\":\\"https://github.com/xuejmnet\\"}]}"],["meta",{"property":"og:url","content":"https://github.com/dromara/easy-query/easy-query-doc/en/what-is-easy-query.html"}],["meta",{"property":"og:site_name","content":"Documentation"}],["meta",{"property":"og:title","content":"What is EQ"}],["meta",{"property":"og:description","content":"easy-query Introduction QQ Group EasyQuery Official QQ Group: 170029046 easy-query Features!!! The most powerful ORM for Java that truly understands queries, perfectly implement..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:locale:alternate","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-10-26T17:39:47.000Z"}],["meta",{"property":"article:modified_time","content":"2025-10-26T17:39:47.000Z"}],["link",{"rel":"alternate","hreflang":"zh-cn","href":"https://github.com/dromara/easy-query/easy-query-doc/what-is-easy-query.html"}]]},"git":{"createdTime":1761500387000,"updatedTime":1761500387000,"contributors":[{"name":"只是我","username":"","email":"alice@example.com","commits":1}]},"readingTime":{"minutes":2.62,"words":785},"filePathRelative":"en/what-is-easy-query.md","autoDesc":true}');export{c as comp,u as data};
